{"version":3,"file":"values.js","sourceRoot":"","sources":["../../src/execution/values.ts"],"names":[],"mappings":"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","sourcesContent":["import { inspect } from '../jsutils/inspect.js';\nimport type { Maybe } from '../jsutils/Maybe.js';\nimport type { ObjMap, ReadOnlyObjMap } from '../jsutils/ObjMap.js';\nimport { printPathArray } from '../jsutils/printPathArray.js';\n\nimport { GraphQLError } from '../error/GraphQLError.js';\n\nimport type {\n  DirectiveNode,\n  FieldNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n} from '../language/ast.js';\nimport { Kind } from '../language/kinds.js';\nimport { print } from '../language/printer.js';\n\nimport type { GraphQLArgument, GraphQLField } from '../type/definition.js';\nimport { isNonNullType } from '../type/definition.js';\nimport type { GraphQLDirective } from '../type/directives.js';\nimport type { GraphQLSchema } from '../type/schema.js';\n\nimport {\n  coerceDefaultValue,\n  coerceInputLiteral,\n  coerceInputValue,\n} from '../utilities/coerceInputValue.js';\n\nimport type { GraphQLVariableSignature } from './getVariableSignature.js';\nimport { getVariableSignature } from './getVariableSignature.js';\n\nexport interface VariableValues {\n  readonly sources: ReadOnlyObjMap<VariableValueSource>;\n  readonly coerced: ReadOnlyObjMap<unknown>;\n}\n\ninterface VariableValueSource {\n  readonly signature: GraphQLVariableSignature;\n  readonly value?: unknown;\n}\n\ntype VariableValuesOrErrors =\n  | { variableValues: VariableValues; errors?: never }\n  | { errors: ReadonlyArray<GraphQLError>; variableValues?: never };\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(\n  schema: GraphQLSchema,\n  varDefNodes: ReadonlyArray<VariableDefinitionNode>,\n  inputs: { readonly [variable: string]: unknown },\n  options?: { maxErrors?: number; hideSuggestions?: boolean },\n): VariableValuesOrErrors {\n  const errors: Array<GraphQLError> = [];\n  const maxErrors = options?.maxErrors;\n  try {\n    const variableValues = coerceVariableValues(\n      schema,\n      varDefNodes,\n      inputs,\n      (error) => {\n        if (maxErrors != null && errors.length >= maxErrors) {\n          throw new GraphQLError(\n            'Too many errors processing variables, error limit reached. Execution aborted.',\n          );\n        }\n        errors.push(error);\n      },\n      options?.hideSuggestions,\n    );\n\n    if (errors.length === 0) {\n      return { variableValues };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return { errors };\n}\n\nfunction coerceVariableValues(\n  schema: GraphQLSchema,\n  varDefNodes: ReadonlyArray<VariableDefinitionNode>,\n  inputs: { readonly [variable: string]: unknown },\n  onError: (error: GraphQLError) => void,\n  hideSuggestions?: Maybe<boolean>,\n): VariableValues {\n  const sources: ObjMap<VariableValueSource> = Object.create(null);\n  const coerced: ObjMap<unknown> = Object.create(null);\n  for (const varDefNode of varDefNodes) {\n    const varSignature = getVariableSignature(schema, varDefNode);\n\n    if (varSignature instanceof GraphQLError) {\n      onError(varSignature);\n      continue;\n    }\n\n    const { name: varName, type: varType } = varSignature;\n    if (!Object.hasOwn(inputs, varName)) {\n      const defaultValue = varSignature.defaultValue;\n      if (defaultValue) {\n        sources[varName] = { signature: varSignature };\n        coerced[varName] = coerceDefaultValue(\n          defaultValue,\n          varType,\n          hideSuggestions,\n        );\n      } else if (isNonNullType(varType)) {\n        const varTypeStr = inspect(varType);\n        onError(\n          new GraphQLError(\n            `Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`,\n            { nodes: varDefNode },\n          ),\n        );\n      } else {\n        sources[varName] = { signature: varSignature };\n      }\n      continue;\n    }\n\n    const value = inputs[varName];\n    if (value === null && isNonNullType(varType)) {\n      const varTypeStr = inspect(varType);\n      onError(\n        new GraphQLError(\n          `Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`,\n          { nodes: varDefNode },\n        ),\n      );\n      continue;\n    }\n\n    sources[varName] = { signature: varSignature, value };\n    coerced[varName] = coerceInputValue(\n      value,\n      varType,\n      (path, invalidValue, error) => {\n        let prefix =\n          `Variable \"$${varName}\" got invalid value ` + inspect(invalidValue);\n        if (path.length > 0) {\n          prefix += ` at \"${varName}${printPathArray(path)}\"`;\n        }\n        onError(\n          new GraphQLError(prefix + '; ' + error.message, {\n            nodes: varDefNode,\n            originalError: error,\n          }),\n        );\n      },\n      hideSuggestions,\n    );\n  }\n\n  return { sources, coerced };\n}\n\nexport function getFragmentVariableValues(\n  fragmentSpreadNode: FragmentSpreadNode,\n  fragmentSignatures: ReadOnlyObjMap<GraphQLVariableSignature>,\n  variableValues: VariableValues,\n  fragmentVariableValues?: Maybe<VariableValues>,\n  hideSuggestions?: Maybe<boolean>,\n): VariableValues {\n  const varSignatures: Array<GraphQLVariableSignature> = [];\n  const sources = Object.create(null);\n  for (const [varName, varSignature] of Object.entries(fragmentSignatures)) {\n    varSignatures.push(varSignature);\n    sources[varName] = {\n      signature: varSignature,\n      value:\n        fragmentVariableValues?.sources[varName]?.value ??\n        variableValues.sources[varName]?.value,\n    };\n  }\n\n  const coerced = experimentalGetArgumentValues(\n    fragmentSpreadNode,\n    varSignatures,\n    variableValues,\n    fragmentVariableValues,\n    hideSuggestions,\n  );\n\n  return { sources, coerced };\n}\n\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getArgumentValues(\n  def: GraphQLField<unknown, unknown> | GraphQLDirective,\n  node: FieldNode | DirectiveNode,\n  variableValues?: Maybe<VariableValues>,\n  hideSuggestions?: Maybe<boolean>,\n): { [argument: string]: unknown } {\n  return experimentalGetArgumentValues(\n    node,\n    def.args,\n    variableValues,\n    undefined,\n    hideSuggestions,\n  );\n}\n\nexport function experimentalGetArgumentValues(\n  node: FieldNode | DirectiveNode | FragmentSpreadNode,\n  argDefs: ReadonlyArray<GraphQLArgument | GraphQLVariableSignature>,\n  variableValues: Maybe<VariableValues>,\n  fragmentVariableValues?: Maybe<VariableValues>,\n  hideSuggestions?: Maybe<boolean>,\n): { [argument: string]: unknown } {\n  const coercedValues: { [argument: string]: unknown } = {};\n\n  const argumentNodes = node.arguments ?? [];\n  const argNodeMap = new Map(argumentNodes.map((arg) => [arg.name.value, arg]));\n\n  for (const argDef of argDefs) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap.get(name);\n\n    if (argumentNode == null) {\n      if (argDef.defaultValue) {\n        coercedValues[name] = coerceDefaultValue(\n          argDef.defaultValue,\n          argDef.type,\n          hideSuggestions,\n        );\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(\n          `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n            'was not provided.',\n          { nodes: node },\n        );\n      }\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === Kind.NULL;\n\n    if (valueNode.kind === Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n      const scopedVariableValues = fragmentVariableValues?.sources[variableName]\n        ? fragmentVariableValues\n        : variableValues;\n      if (\n        scopedVariableValues == null ||\n        !Object.hasOwn(scopedVariableValues.coerced, variableName)\n      ) {\n        if (argDef.defaultValue) {\n          coercedValues[name] = coerceDefaultValue(\n            argDef.defaultValue,\n            argDef.type,\n            hideSuggestions,\n          );\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(\n            `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n              `was provided the variable \"$${variableName}\" which was not provided a runtime value.`,\n            { nodes: valueNode },\n          );\n        }\n        continue;\n      }\n      isNull = scopedVariableValues.coerced[variableName] == null;\n    }\n\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(\n        `Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` +\n          'must not be null.',\n        { nodes: valueNode },\n      );\n    }\n\n    const coercedValue = coerceInputLiteral(\n      valueNode,\n      argType,\n      variableValues,\n      fragmentVariableValues,\n      hideSuggestions,\n    );\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(\n        `Argument \"${name}\" of type \"${inspect(\n          argType,\n        )}\" has invalid value ${print(valueNode)}.`,\n        { nodes: valueNode },\n      );\n    }\n    coercedValues[name] = coercedValue;\n  }\n  return coercedValues;\n}\n\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getDirectiveValues(\n  directiveDef: GraphQLDirective,\n  node: { readonly directives?: ReadonlyArray<DirectiveNode> | undefined },\n  variableValues?: Maybe<VariableValues>,\n  fragmentVariableValues?: Maybe<VariableValues>,\n  hideSuggestions?: Maybe<boolean>,\n): undefined | { [argument: string]: unknown } {\n  const directiveNode = node.directives?.find(\n    (directive) => directive.name.value === directiveDef.name,\n  );\n\n  if (directiveNode) {\n    return experimentalGetArgumentValues(\n      directiveNode,\n      directiveDef.args,\n      variableValues,\n      fragmentVariableValues,\n      hideSuggestions,\n    );\n  }\n}\n"]}