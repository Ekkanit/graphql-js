{"version":3,"file":"mapAsyncIterable.js","sourceRoot":"","sources":["../../src/execution/mapAsyncIterable.ts"],"names":[],"mappings":"AAEA;;;GAGG;AACH,MAAM,UAAU,gBAAgB,CAC9B,QAAuD,EACvD,QAAyC;IAEzC,MAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;IAElD,KAAK,UAAU,SAAS,CACtB,MAA4B;QAE5B,IAAI,MAAM,CAAC,IAAI,EAAE,CAAC;YAChB,OAAO,MAAM,CAAC;QAChB,CAAC;QAED,IAAI,CAAC;YACH,OAAO,EAAE,KAAK,EAAE,MAAM,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;QAC9D,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,qBAAqB;YACrB,uBAAuB;YACvB,IAAI,OAAO,QAAQ,CAAC,MAAM,KAAK,UAAU,EAAE,CAAC;gBAC1C,IAAI,CAAC;oBACH,MAAM,QAAQ,CAAC,MAAM,EAAE,CAAC;gBAC1B,CAAC;gBAAC,OAAO,EAAE,EAAE,CAAC;oBACZ,kBAAkB;gBACpB,CAAC;YACH,CAAC;YACD,MAAM,KAAK,CAAC;YACZ,oBAAoB;QACtB,CAAC;IACH,CAAC;IAED,OAAO;QACL,KAAK,CAAC,IAAI;YACR,OAAO,SAAS,CAAC,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC;QAC1C,CAAC;QACD,KAAK,CAAC,MAAM;YACV,sEAAsE;YACtE,OAAO,OAAO,QAAQ,CAAC,MAAM,KAAK,UAAU;gBAC1C,CAAC,CAAC,SAAS,CAAC,MAAM,QAAQ,CAAC,MAAM,EAAE,CAAC;gBACpC,CAAC,CAAC,EAAE,KAAK,EAAE,SAAgB,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;QAC9C,CAAC;QACD,KAAK,CAAC,KAAK,CAAC,KAAe;YACzB,IAAI,OAAO,QAAQ,CAAC,KAAK,KAAK,UAAU,EAAE,CAAC;gBACzC,OAAO,SAAS,CAAC,MAAM,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;YAChD,CAAC;YACD,MAAM,KAAK,CAAC;QACd,CAAC;QACD,CAAC,MAAM,CAAC,aAAa,CAAC;YACpB,OAAO,IAAI,CAAC;QACd,CAAC;KACF,CAAC;AACJ,CAAC","sourcesContent":["import type { PromiseOrValue } from '../jsutils/PromiseOrValue.js';\n\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport function mapAsyncIterable<T, U, R = undefined>(\n  iterable: AsyncGenerator<T, R, void> | AsyncIterable<T>,\n  callback: (value: T) => PromiseOrValue<U>,\n): AsyncGenerator<U, R, void> {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  async function mapResult(\n    result: IteratorResult<T, R>,\n  ): Promise<IteratorResult<U, R>> {\n    if (result.done) {\n      return result;\n    }\n\n    try {\n      return { value: await callback(result.value), done: false };\n    } catch (error) {\n      /* c8 ignore start */\n      // FIXME: add test case\n      if (typeof iterator.return === 'function') {\n        try {\n          await iterator.return();\n        } catch (_e) {\n          /* ignore error */\n        }\n      }\n      throw error;\n      /* c8 ignore stop */\n    }\n  }\n\n  return {\n    async next() {\n      return mapResult(await iterator.next());\n    },\n    async return(): Promise<IteratorResult<U, R>> {\n      // If iterator.return() does not exist, then type R must be undefined.\n      return typeof iterator.return === 'function'\n        ? mapResult(await iterator.return())\n        : { value: undefined as any, done: true };\n    },\n    async throw(error?: unknown) {\n      if (typeof iterator.throw === 'function') {\n        return mapResult(await iterator.throw(error));\n      }\n      throw error;\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n"]}