{"version":3,"file":"extendSchema.js","sourceRoot":"","sources":["../../src/utilities/extendSchema.ts"],"names":[],"mappings":"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","sourcesContent":["import { AccumulatorMap } from '../jsutils/AccumulatorMap.js';\nimport { inspect } from '../jsutils/inspect.js';\nimport { invariant } from '../jsutils/invariant.js';\nimport { mapValue } from '../jsutils/mapValue.js';\nimport type { Maybe } from '../jsutils/Maybe.js';\n\nimport type {\n  DirectiveDefinitionNode,\n  DocumentNode,\n  EnumTypeDefinitionNode,\n  EnumTypeExtensionNode,\n  EnumValueDefinitionNode,\n  FieldDefinitionNode,\n  InputObjectTypeDefinitionNode,\n  InputObjectTypeExtensionNode,\n  InputValueDefinitionNode,\n  InterfaceTypeDefinitionNode,\n  InterfaceTypeExtensionNode,\n  NamedTypeNode,\n  ObjectTypeDefinitionNode,\n  ObjectTypeExtensionNode,\n  ScalarTypeDefinitionNode,\n  ScalarTypeExtensionNode,\n  SchemaDefinitionNode,\n  SchemaExtensionNode,\n  TypeDefinitionNode,\n  TypeNode,\n  UnionTypeDefinitionNode,\n  UnionTypeExtensionNode,\n} from '../language/ast.js';\nimport { Kind } from '../language/kinds.js';\n\nimport type {\n  GraphQLArgumentConfig,\n  GraphQLEnumValueConfigMap,\n  GraphQLFieldConfig,\n  GraphQLFieldConfigArgumentMap,\n  GraphQLFieldConfigMap,\n  GraphQLInputFieldConfigMap,\n  GraphQLNamedType,\n  GraphQLType,\n} from '../type/definition.js';\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../type/definition.js';\nimport {\n  GraphQLDeprecatedDirective,\n  GraphQLDirective,\n  GraphQLOneOfDirective,\n  GraphQLSpecifiedByDirective,\n  isSpecifiedDirective,\n} from '../type/directives.js';\nimport {\n  introspectionTypes,\n  isIntrospectionType,\n} from '../type/introspection.js';\nimport {\n  isSpecifiedScalarType,\n  specifiedScalarTypes,\n} from '../type/scalars.js';\nimport type {\n  GraphQLSchemaNormalizedConfig,\n  GraphQLSchemaValidationOptions,\n} from '../type/schema.js';\nimport { assertSchema, GraphQLSchema } from '../type/schema.js';\n\nimport { assertValidSDLExtension } from '../validation/validate.js';\n\nimport { getDirectiveValues } from '../execution/values.js';\n\ninterface Options extends GraphQLSchemaValidationOptions {\n  /**\n   * Set to true to assume the SDL is valid.\n   *\n   * Default: false\n   */\n  assumeValidSDL?: boolean | undefined;\n}\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\nexport function extendSchema(\n  schema: GraphQLSchema,\n  documentAST: DocumentNode,\n  options?: Options,\n): GraphQLSchema {\n  assertSchema(schema);\n\n  if (options?.assumeValid !== true && options?.assumeValidSDL !== true) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n\n  const schemaConfig = schema.toConfig();\n  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig\n    ? schema\n    : new GraphQLSchema(extendedConfig);\n}\n\n/**\n * @internal\n */\nexport function extendSchemaImpl(\n  schemaConfig: GraphQLSchemaNormalizedConfig,\n  documentAST: DocumentNode,\n  options?: Options,\n): GraphQLSchemaNormalizedConfig {\n  // Collect the type definitions and extensions found in the document.\n  const typeDefs: Array<TypeDefinitionNode> = [];\n\n  const scalarExtensions = new AccumulatorMap<\n    string,\n    ScalarTypeExtensionNode\n  >();\n  const objectExtensions = new AccumulatorMap<\n    string,\n    ObjectTypeExtensionNode\n  >();\n  const interfaceExtensions = new AccumulatorMap<\n    string,\n    InterfaceTypeExtensionNode\n  >();\n  const unionExtensions = new AccumulatorMap<string, UnionTypeExtensionNode>();\n  const enumExtensions = new AccumulatorMap<string, EnumTypeExtensionNode>();\n  const inputObjectExtensions = new AccumulatorMap<\n    string,\n    InputObjectTypeExtensionNode\n  >();\n\n  // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n  const directiveDefs: Array<DirectiveDefinitionNode> = [];\n\n  let schemaDef: Maybe<SchemaDefinitionNode>;\n  // Schema extensions are collected which may add additional operation types.\n  const schemaExtensions: Array<SchemaExtensionNode> = [];\n\n  let isSchemaChanged = false;\n  for (const def of documentAST.definitions) {\n    switch (def.kind) {\n      case Kind.SCHEMA_DEFINITION:\n        schemaDef = def;\n        break;\n      case Kind.SCHEMA_EXTENSION:\n        schemaExtensions.push(def);\n        break;\n      case Kind.DIRECTIVE_DEFINITION:\n        directiveDefs.push(def);\n        break;\n\n      // Type Definitions\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        typeDefs.push(def);\n        break;\n\n      // Type System Extensions\n      case Kind.SCALAR_TYPE_EXTENSION:\n        scalarExtensions.add(def.name.value, def);\n        break;\n      case Kind.OBJECT_TYPE_EXTENSION:\n        objectExtensions.add(def.name.value, def);\n        break;\n      case Kind.INTERFACE_TYPE_EXTENSION:\n        interfaceExtensions.add(def.name.value, def);\n        break;\n      case Kind.UNION_TYPE_EXTENSION:\n        unionExtensions.add(def.name.value, def);\n        break;\n      case Kind.ENUM_TYPE_EXTENSION:\n        enumExtensions.add(def.name.value, def);\n        break;\n      case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n        inputObjectExtensions.add(def.name.value, def);\n        break;\n      default:\n        continue;\n    }\n    isSchemaChanged = true;\n  }\n\n  // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n  if (!isSchemaChanged) {\n    return schemaConfig;\n  }\n\n  const typeMap = new Map<string, GraphQLNamedType>(\n    schemaConfig.types.map((type) => [type.name, extendNamedType(type)]),\n  );\n\n  for (const typeNode of typeDefs) {\n    const name = typeNode.name.value;\n    typeMap.set(name, stdTypeMap.get(name) ?? buildType(typeNode));\n  }\n\n  const operationTypes = {\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription:\n      schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),\n    // Then, incorporate schema definition and all schema extensions.\n    ...(schemaDef && getOperationTypes([schemaDef])),\n    ...getOperationTypes(schemaExtensions),\n  };\n\n  // Then produce and return a Schema config with these types.\n  return {\n    description: schemaDef?.description?.value ?? schemaConfig.description,\n    ...operationTypes,\n    types: Array.from(typeMap.values()),\n    directives: [\n      ...schemaConfig.directives.map(replaceDirective),\n      ...directiveDefs.map(buildDirective),\n    ],\n    extensions: schemaConfig.extensions,\n    astNode: schemaDef ?? schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid: options?.assumeValid ?? false,\n  };\n\n  // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType<T extends GraphQLType>(type: T): T {\n    if (isListType(type)) {\n      // @ts-expect-error\n      return new GraphQLList(replaceType(type.ofType));\n    }\n    if (isNonNullType(type)) {\n      // @ts-expect-error\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n    // @ts-expect-error FIXME\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType<T extends GraphQLNamedType>(type: T): T {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap.get(type.name) as T;\n  }\n\n  function replaceDirective(directive: GraphQLDirective): GraphQLDirective {\n    if (isSpecifiedDirective(directive)) {\n      // Builtin directives are not extended.\n      return directive;\n    }\n\n    const config = directive.toConfig();\n    return new GraphQLDirective({\n      ...config,\n      args: mapValue(config.args, extendArg),\n    });\n  }\n\n  function extendNamedType(type: GraphQLNamedType): GraphQLNamedType {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n    if (isScalarType(type)) {\n      return extendScalarType(type);\n    }\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n    if (isEnumType(type)) {\n      return extendEnumType(type);\n    }\n    if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible type definition nodes have been considered.\n    invariant(false, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendInputObjectType(\n    type: GraphQLInputObjectType,\n  ): GraphQLInputObjectType {\n    const config = type.toConfig();\n    const extensions = inputObjectExtensions.get(config.name) ?? [];\n\n    return new GraphQLInputObjectType({\n      ...config,\n      fields: () => ({\n        ...mapValue(config.fields, (field) => ({\n          ...field,\n          type: replaceType(field.type),\n        })),\n        ...buildInputFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendEnumType(type: GraphQLEnumType): GraphQLEnumType {\n    const config = type.toConfig();\n    const extensions = enumExtensions.get(type.name) ?? [];\n\n    return new GraphQLEnumType({\n      ...config,\n      values: {\n        ...config.values,\n        ...buildEnumValueMap(extensions),\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendScalarType(type: GraphQLScalarType): GraphQLScalarType {\n    const config = type.toConfig();\n    const extensions = scalarExtensions.get(config.name) ?? [];\n\n    let specifiedByURL = config.specifiedByURL;\n    for (const extensionNode of extensions) {\n      specifiedByURL = getSpecifiedByURL(extensionNode) ?? specifiedByURL;\n    }\n\n    return new GraphQLScalarType({\n      ...config,\n      specifiedByURL,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendObjectType(type: GraphQLObjectType): GraphQLObjectType {\n    const config = type.toConfig();\n    const extensions = objectExtensions.get(config.name) ?? [];\n\n    return new GraphQLObjectType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...mapValue(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendInterfaceType(\n    type: GraphQLInterfaceType,\n  ): GraphQLInterfaceType {\n    const config = type.toConfig();\n    const extensions = interfaceExtensions.get(config.name) ?? [];\n\n    return new GraphQLInterfaceType({\n      ...config,\n      interfaces: () => [\n        ...type.getInterfaces().map(replaceNamedType),\n        ...buildInterfaces(extensions),\n      ],\n      fields: () => ({\n        ...mapValue(config.fields, extendField),\n        ...buildFieldMap(extensions),\n      }),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendUnionType(type: GraphQLUnionType): GraphQLUnionType {\n    const config = type.toConfig();\n    const extensions = unionExtensions.get(config.name) ?? [];\n\n    return new GraphQLUnionType({\n      ...config,\n      types: () => [\n        ...type.getTypes().map(replaceNamedType),\n        ...buildUnionTypes(extensions),\n      ],\n      extensionASTNodes: config.extensionASTNodes.concat(extensions),\n    });\n  }\n\n  function extendField(\n    field: GraphQLFieldConfig<unknown, unknown>,\n  ): GraphQLFieldConfig<unknown, unknown> {\n    return {\n      ...field,\n      type: replaceType(field.type),\n      args: field.args && mapValue(field.args, extendArg),\n    };\n  }\n\n  function extendArg(arg: GraphQLArgumentConfig) {\n    return {\n      ...arg,\n      type: replaceType(arg.type),\n    };\n  }\n\n  function getOperationTypes(\n    nodes: ReadonlyArray<SchemaDefinitionNode | SchemaExtensionNode>,\n  ): {\n    query?: Maybe<GraphQLObjectType>;\n    mutation?: Maybe<GraphQLObjectType>;\n    subscription?: Maybe<GraphQLObjectType>;\n  } {\n    const opTypes = {};\n    for (const node of nodes) {\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const operationTypesNodes =\n        /* c8 ignore next */ node.operationTypes ?? [];\n\n      for (const operationType of operationTypesNodes) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        // @ts-expect-error\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    }\n\n    return opTypes;\n  }\n\n  function getNamedType(node: NamedTypeNode): GraphQLNamedType {\n    const name = node.name.value;\n    const type = stdTypeMap.get(name) ?? typeMap.get(name);\n\n    if (type === undefined) {\n      throw new Error(`Unknown type: \"${name}\".`);\n    }\n    return type;\n  }\n\n  function getWrappedType(node: TypeNode): GraphQLType {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n    return getNamedType(node);\n  }\n\n  function buildDirective(node: DirectiveDefinitionNode): GraphQLDirective {\n    return new GraphQLDirective({\n      name: node.name.value,\n      description: node.description?.value,\n      // @ts-expect-error\n      locations: node.locations.map(({ value }) => value),\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node,\n    });\n  }\n\n  function buildFieldMap(\n    nodes: ReadonlyArray<\n      | InterfaceTypeDefinitionNode\n      | InterfaceTypeExtensionNode\n      | ObjectTypeDefinitionNode\n      | ObjectTypeExtensionNode\n    >,\n  ): GraphQLFieldConfigMap<unknown, unknown> {\n    const fieldConfigMap = Object.create(null);\n    for (const node of nodes) {\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const nodeFields = /* c8 ignore next */ node.fields ?? [];\n\n      for (const field of nodeFields) {\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description: field.description?.value,\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(\n    args: Maybe<ReadonlyArray<InputValueDefinitionNode>>,\n  ): GraphQLFieldConfigArgumentMap {\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n    const argsNodes = /* c8 ignore next */ args ?? [];\n\n    const argConfigMap = Object.create(null);\n    for (const arg of argsNodes) {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      const type: any = getWrappedType(arg.type);\n\n      argConfigMap[arg.name.value] = {\n        type,\n        description: arg.description?.value,\n        defaultValueLiteral: arg.defaultValue,\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg,\n      };\n    }\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(\n    nodes: ReadonlyArray<\n      InputObjectTypeDefinitionNode | InputObjectTypeExtensionNode\n    >,\n  ): GraphQLInputFieldConfigMap {\n    const inputFieldMap = Object.create(null);\n    for (const node of nodes) {\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const fieldsNodes = /* c8 ignore next */ node.fields ?? [];\n\n      for (const field of fieldsNodes) {\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        const type: any = getWrappedType(field.type);\n\n        inputFieldMap[field.name.value] = {\n          type,\n          description: field.description?.value,\n          defaultValueLiteral: field.defaultValue,\n          deprecationReason: getDeprecationReason(field),\n          astNode: field,\n        };\n      }\n    }\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(\n    nodes: ReadonlyArray<EnumTypeDefinitionNode | EnumTypeExtensionNode>,\n  ): GraphQLEnumValueConfigMap {\n    const enumValueMap = Object.create(null);\n    for (const node of nodes) {\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      const valuesNodes = /* c8 ignore next */ node.values ?? [];\n\n      for (const value of valuesNodes) {\n        enumValueMap[value.name.value] = {\n          description: value.description?.value,\n          deprecationReason: getDeprecationReason(value),\n          astNode: value,\n        };\n      }\n    }\n    return enumValueMap;\n  }\n\n  function buildInterfaces(\n    nodes: ReadonlyArray<\n      | InterfaceTypeDefinitionNode\n      | InterfaceTypeExtensionNode\n      | ObjectTypeDefinitionNode\n      | ObjectTypeExtensionNode\n    >,\n  ): Array<GraphQLInterfaceType> {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (node) => /* c8 ignore next */ node.interfaces?.map(getNamedType) ?? [],\n    );\n  }\n\n  function buildUnionTypes(\n    nodes: ReadonlyArray<UnionTypeDefinitionNode | UnionTypeExtensionNode>,\n  ): Array<GraphQLObjectType> {\n    // Note: While this could make assertions to get the correctly typed\n    // values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    // @ts-expect-error\n    return nodes.flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (node) => /* c8 ignore next */ node.types?.map(getNamedType) ?? [],\n    );\n  }\n\n  function buildType(astNode: TypeDefinitionNode): GraphQLNamedType {\n    const name = astNode.name.value;\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION: {\n        const extensionASTNodes = objectExtensions.get(name) ?? [];\n        const allNodes = [astNode, ...extensionASTNodes];\n\n        return new GraphQLObjectType({\n          name,\n          description: astNode.description?.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n      case Kind.INTERFACE_TYPE_DEFINITION: {\n        const extensionASTNodes = interfaceExtensions.get(name) ?? [];\n        const allNodes = [astNode, ...extensionASTNodes];\n\n        return new GraphQLInterfaceType({\n          name,\n          description: astNode.description?.value,\n          interfaces: () => buildInterfaces(allNodes),\n          fields: () => buildFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n      case Kind.ENUM_TYPE_DEFINITION: {\n        const extensionASTNodes = enumExtensions.get(name) ?? [];\n        const allNodes = [astNode, ...extensionASTNodes];\n\n        return new GraphQLEnumType({\n          name,\n          description: astNode.description?.value,\n          values: buildEnumValueMap(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n      case Kind.UNION_TYPE_DEFINITION: {\n        const extensionASTNodes = unionExtensions.get(name) ?? [];\n        const allNodes = [astNode, ...extensionASTNodes];\n\n        return new GraphQLUnionType({\n          name,\n          description: astNode.description?.value,\n          types: () => buildUnionTypes(allNodes),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n      case Kind.SCALAR_TYPE_DEFINITION: {\n        const extensionASTNodes = scalarExtensions.get(name) ?? [];\n        return new GraphQLScalarType({\n          name,\n          description: astNode.description?.value,\n          specifiedByURL: getSpecifiedByURL(astNode),\n          astNode,\n          extensionASTNodes,\n        });\n      }\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {\n        const extensionASTNodes = inputObjectExtensions.get(name) ?? [];\n        const allNodes = [astNode, ...extensionASTNodes];\n\n        return new GraphQLInputObjectType({\n          name,\n          description: astNode.description?.value,\n          fields: () => buildInputFieldMap(allNodes),\n          astNode,\n          extensionASTNodes,\n          isOneOf: isOneOf(astNode),\n        });\n      }\n    }\n  }\n}\n\nconst stdTypeMap = new Map(\n  [...specifiedScalarTypes, ...introspectionTypes].map((type) => [\n    type.name,\n    type,\n  ]),\n);\n\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\nfunction getDeprecationReason(\n  node:\n    | EnumValueDefinitionNode\n    | FieldDefinitionNode\n    | InputValueDefinitionNode,\n): Maybe<string> {\n  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  // @ts-expect-error validated by `getDirectiveValues`\n  return deprecated?.reason;\n}\n\n/**\n * Given a scalar node, returns the string value for the specifiedByURL.\n */\nfunction getSpecifiedByURL(\n  node: ScalarTypeDefinitionNode | ScalarTypeExtensionNode,\n): Maybe<string> {\n  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);\n  // @ts-expect-error validated by `getDirectiveValues`\n  return specifiedBy?.url;\n}\n\n/**\n * Given an input object node, returns if the node should be OneOf.\n */\nfunction isOneOf(node: InputObjectTypeDefinitionNode): boolean {\n  return Boolean(getDirectiveValues(GraphQLOneOfDirective, node));\n}\n"]}