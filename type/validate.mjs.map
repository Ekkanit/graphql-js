{"version":3,"file":"validate.js","sourceRoot":"","sources":["../../src/type/validate.ts"],"names":[],"mappings":"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","sourcesContent":["import { AccumulatorMap } from '../jsutils/AccumulatorMap.js';\nimport { capitalize } from '../jsutils/capitalize.js';\nimport { andList } from '../jsutils/formatList.js';\nimport { inspect } from '../jsutils/inspect.js';\nimport type { Maybe } from '../jsutils/Maybe.js';\n\nimport { GraphQLError } from '../error/GraphQLError.js';\n\nimport type {\n  ASTNode,\n  DirectiveNode,\n  InterfaceTypeDefinitionNode,\n  InterfaceTypeExtensionNode,\n  NamedTypeNode,\n  ObjectTypeDefinitionNode,\n  ObjectTypeExtensionNode,\n  UnionTypeDefinitionNode,\n  UnionTypeExtensionNode,\n} from '../language/ast.js';\nimport { OperationTypeNode } from '../language/ast.js';\n\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators.js';\n\nimport type {\n  GraphQLEnumType,\n  GraphQLInputField,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLUnionType,\n} from './definition.js';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInputType,\n  isInterfaceType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isOutputType,\n  isRequiredArgument,\n  isRequiredInputField,\n  isUnionType,\n} from './definition.js';\nimport { GraphQLDeprecatedDirective, isDirective } from './directives.js';\nimport { isIntrospectionType } from './introspection.js';\nimport type { GraphQLSchema } from './schema.js';\nimport { assertSchema } from './schema.js';\n\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\nexport function validateSchema(\n  schema: GraphQLSchema,\n): ReadonlyArray<GraphQLError> {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema);\n\n  // If this Schema has already been validated, return the previous results.\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  }\n\n  // Validate the schema, producing a list of errors.\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context);\n\n  // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\nexport function assertValidSchema(schema: GraphQLSchema): void {\n  const errors = validateSchema(schema);\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n\nclass SchemaValidationContext {\n  readonly _errors: Array<GraphQLError>;\n  readonly schema: GraphQLSchema;\n\n  constructor(schema: GraphQLSchema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  reportError(\n    message: string,\n    nodes?: ReadonlyArray<Maybe<ASTNode>> | Maybe<ASTNode>,\n  ): void {\n    const _nodes = Array.isArray(nodes)\n      ? (nodes.filter(Boolean) as ReadonlyArray<ASTNode>)\n      : (nodes as Maybe<ASTNode>);\n    this._errors.push(new GraphQLError(message, { nodes: _nodes }));\n  }\n\n  getErrors(): ReadonlyArray<GraphQLError> {\n    return this._errors;\n  }\n}\n\nfunction validateRootTypes(context: SchemaValidationContext): void {\n  const schema = context.schema;\n\n  if (schema.getQueryType() == null) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  }\n\n  const rootTypesMap = new AccumulatorMap<\n    GraphQLObjectType,\n    OperationTypeNode\n  >();\n  for (const operationType of Object.values(OperationTypeNode)) {\n    const rootType = schema.getRootType(operationType);\n\n    if (rootType != null) {\n      if (!isObjectType(rootType)) {\n        const operationTypeStr = capitalize(operationType);\n        const rootTypeStr = inspect(rootType);\n        context.reportError(\n          operationType === OperationTypeNode.QUERY\n            ? `${operationTypeStr} root type must be Object type, it cannot be ${rootTypeStr}.`\n            : `${operationTypeStr} root type must be Object type if provided, it cannot be ${rootTypeStr}.`,\n          getOperationTypeNode(schema, operationType) ??\n            (rootType as any).astNode,\n        );\n      } else {\n        rootTypesMap.add(rootType, operationType);\n      }\n    }\n  }\n\n  for (const [rootType, operationTypes] of rootTypesMap) {\n    if (operationTypes.length > 1) {\n      const operationList = andList(operationTypes);\n      context.reportError(\n        `All root types must be different, \"${rootType}\" type is used as ${operationList} root types.`,\n        operationTypes.map((operationType) =>\n          getOperationTypeNode(schema, operationType),\n        ),\n      );\n    }\n  }\n}\n\nfunction getOperationTypeNode(\n  schema: GraphQLSchema,\n  operation: OperationTypeNode,\n): Maybe<ASTNode> {\n  return [schema.astNode, ...schema.extensionASTNodes]\n    .flatMap((schemaNode) => schemaNode?.operationTypes ?? [])\n    .find((operationNode) => operationNode.operation === operation)?.type;\n}\n\nfunction validateDirectives(context: SchemaValidationContext): void {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\n        `Expected directive but got: ${inspect(directive)}.`,\n        (directive as any)?.astNode,\n      );\n      continue;\n    }\n\n    // Ensure they are named correctly.\n    validateName(context, directive);\n\n    if (directive.locations.length === 0) {\n      context.reportError(\n        `Directive ${directive} must include 1 or more locations.`,\n        directive.astNode,\n      );\n    }\n\n    // Ensure the arguments are valid.\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg);\n\n      // Ensure the type is an input type.\n      if (!isInputType(arg.type)) {\n        context.reportError(\n          `The type of ${directive}(${arg.name}:) must be Input Type ` +\n            `but got: ${inspect(arg.type)}.`,\n          arg.astNode,\n        );\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        context.reportError(\n          `Required argument ${directive}(${arg.name}:) cannot be deprecated.`,\n          [getDeprecatedDirectiveNode(arg.astNode), arg.astNode?.type],\n        );\n      }\n    }\n  }\n}\n\nfunction validateName(\n  context: SchemaValidationContext,\n  node: { readonly name: string; readonly astNode: Maybe<ASTNode> },\n): void {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(\n      `Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n      node.astNode,\n    );\n  }\n}\n\nfunction validateTypes(context: SchemaValidationContext): void {\n  const validateInputObjectCircularRefs =\n    createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\n        `Expected GraphQL named type but got: ${inspect(type)}.`,\n        (type as any).astNode,\n      );\n      continue;\n    }\n\n    // Ensure it is named correctly (excluding introspection types).\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type);\n\n      // Ensure objects implement the interfaces they claim to.\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type);\n\n      // Ensure interfaces implement the interfaces they claim to.\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type);\n\n      // Ensure Input Objects do not contain non-nullable circular references\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(\n  context: SchemaValidationContext,\n  type: GraphQLObjectType | GraphQLInterfaceType,\n): void {\n  const fields = Object.values(type.getFields());\n\n  // Objects and Interfaces both must define one or more fields.\n  if (fields.length === 0) {\n    context.reportError(`Type ${type} must define one or more fields.`, [\n      type.astNode,\n      ...type.extensionASTNodes,\n    ]);\n  }\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field);\n\n    // Ensure the type is an output type\n    if (!isOutputType(field.type)) {\n      context.reportError(\n        `The type of ${type}.${field.name} must be Output Type ` +\n          `but got: ${inspect(field.type)}.`,\n        field.astNode?.type,\n      );\n    }\n\n    // Ensure the arguments are valid\n    for (const arg of field.args) {\n      const argName = arg.name;\n\n      // Ensure they are named correctly.\n      validateName(context, arg);\n\n      // Ensure the type is an input type\n      if (!isInputType(arg.type)) {\n        context.reportError(\n          `The type of ${type}.${field.name}(${argName}:) must be Input ` +\n            `Type but got: ${inspect(arg.type)}.`,\n          arg.astNode?.type,\n        );\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        context.reportError(\n          `Required argument ${type}.${field.name}(${argName}:) cannot be deprecated.`,\n          [getDeprecatedDirectiveNode(arg.astNode), arg.astNode?.type],\n        );\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(\n  context: SchemaValidationContext,\n  type: GraphQLObjectType | GraphQLInterfaceType,\n): void {\n  const ifaceTypeNames = new Set<string>();\n  for (const iface of type.getInterfaces()) {\n    if (!isInterfaceType(iface)) {\n      context.reportError(\n        `Type ${inspect(type)} must only implement Interface types, ` +\n          `it cannot implement ${inspect(iface)}.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\n        `Type ${type} cannot implement itself because it would create a circular reference.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (ifaceTypeNames.has(iface.name)) {\n      context.reportError(\n        `Type ${type} can only implement ${iface.name} once.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    ifaceTypeNames.add(iface.name);\n\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(\n  context: SchemaValidationContext,\n  type: GraphQLObjectType | GraphQLInterfaceType,\n  iface: GraphQLInterfaceType,\n): void {\n  const typeFieldMap = type.getFields();\n\n  // Assert each interface field is implemented.\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName];\n\n    // Assert interface field exists on type.\n    if (typeField == null) {\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expected but ${type} does not provide it.`,\n        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes],\n      );\n      continue;\n    }\n\n    // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expects type ` +\n          `${inspect(ifaceField.type)} but ${type}.${fieldName} ` +\n          `is type ${inspect(typeField.type)}.`,\n        [ifaceField.astNode?.type, typeField.astNode?.type],\n      );\n    }\n\n    // Assert each interface field arg is implemented.\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find((arg) => arg.name === argName);\n\n      // Assert interface field arg exists on object field.\n      if (!typeArg) {\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type}.${fieldName} does not provide it.`,\n          [ifaceArg.astNode, typeField.astNode],\n        );\n        continue;\n      }\n\n      // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) ` +\n            `expects type ${inspect(ifaceArg.type)} but ` +\n            `${type}.${fieldName}(${argName}:) is type ` +\n            `${inspect(typeArg.type)}.`,\n          [ifaceArg.astNode?.type, typeArg.astNode?.type],\n        );\n      }\n\n      // TODO: validate default values?\n    }\n\n    // Assert additional arguments must not be required.\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(\n          `Argument \"${type}.${fieldName}(${argName}:)\" must not be required type \"${inspect(\n            typeArg.type,\n          )}\" if not provided by the Interface field \"${\n            iface.name\n          }.${fieldName}\".`,\n          [typeArg.astNode, ifaceField.astNode],\n        );\n      }\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(\n  context: SchemaValidationContext,\n  type: GraphQLObjectType | GraphQLInterfaceType,\n  iface: GraphQLInterfaceType,\n): void {\n  const ifaceInterfaces = type.getInterfaces();\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(\n        transitive === type\n          ? `Type ${type} cannot implement ${iface.name} because it would create a circular reference.`\n          : `Type ${type} must implement ${transitive.name} because it is implemented by ${iface.name}.`,\n        [\n          ...getAllImplementsInterfaceNodes(iface, transitive),\n          ...getAllImplementsInterfaceNodes(type, iface),\n        ],\n      );\n    }\n  }\n}\n\nfunction validateUnionMembers(\n  context: SchemaValidationContext,\n  union: GraphQLUnionType,\n): void {\n  const memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\n      `Union type ${union.name} must define one or more member types.`,\n      [union.astNode, ...union.extensionASTNodes],\n    );\n  }\n\n  const includedTypeNames = new Set<string>();\n  for (const memberType of memberTypes) {\n    if (includedTypeNames.has(memberType.name)) {\n      context.reportError(\n        `Union type ${union.name} can only include type ${memberType} once.`,\n        getUnionMemberTypeNodes(union, memberType.name),\n      );\n      continue;\n    }\n    includedTypeNames.add(memberType.name);\n    if (!isObjectType(memberType)) {\n      context.reportError(\n        `Union type ${union.name} can only include Object types, ` +\n          `it cannot include ${inspect(memberType)}.`,\n        getUnionMemberTypeNodes(union, String(memberType)),\n      );\n    }\n  }\n}\n\nfunction validateEnumValues(\n  context: SchemaValidationContext,\n  enumType: GraphQLEnumType,\n): void {\n  const enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\n      `Enum type ${enumType} must define one or more values.`,\n      [enumType.astNode, ...enumType.extensionASTNodes],\n    );\n  }\n\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\n\nfunction validateInputFields(\n  context: SchemaValidationContext,\n  inputObj: GraphQLInputObjectType,\n): void {\n  const fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\n      `Input Object type ${inputObj.name} must define one or more fields.`,\n      [inputObj.astNode, ...inputObj.extensionASTNodes],\n    );\n  }\n\n  // Ensure the arguments are valid\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field);\n\n    // Ensure the type is an input type\n    if (!isInputType(field.type)) {\n      context.reportError(\n        `The type of ${inputObj.name}.${field.name} must be Input Type ` +\n          `but got: ${inspect(field.type)}.`,\n        field.astNode?.type,\n      );\n    }\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      context.reportError(\n        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,\n        [getDeprecatedDirectiveNode(field.astNode), field.astNode?.type],\n      );\n    }\n\n    if (inputObj.isOneOf) {\n      validateOneOfInputObjectField(inputObj, field, context);\n    }\n  }\n}\n\nfunction validateOneOfInputObjectField(\n  type: GraphQLInputObjectType,\n  field: GraphQLInputField,\n  context: SchemaValidationContext,\n): void {\n  if (isNonNullType(field.type)) {\n    context.reportError(\n      `OneOf input field ${type}.${field.name} must be nullable.`,\n      field.astNode?.type,\n    );\n  }\n\n  if (field.defaultValue !== undefined) {\n    context.reportError(\n      `OneOf input field ${type}.${field.name} cannot have a default value.`,\n      field.astNode,\n    );\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(\n  context: SchemaValidationContext,\n): (inputObj: GraphQLInputObjectType) => void {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = new Set<GraphQLInputObjectType>();\n\n  // Array of types nodes used to produce meaningful errors\n  const fieldPath: Array<GraphQLInputField> = [];\n\n  // Position in the type path\n  const fieldPathIndexByTypeName = Object.create(null);\n\n  return detectCycleRecursive;\n\n  // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n  function detectCycleRecursive(inputObj: GraphQLInputObjectType): void {\n    if (visitedTypes.has(inputObj)) {\n      return;\n    }\n\n    visitedTypes.add(inputObj);\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n\n    const fields = Object.values(inputObj.getFields());\n    for (const field of fields) {\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n\n        fieldPath.push(field);\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join('.');\n          context.reportError(\n            `Cannot reference Input Object \"${fieldType}\" within itself through a series of non-null fields: \"${pathStr}\".`,\n            cyclePath.map((fieldObj) => fieldObj.astNode),\n          );\n        }\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(\n  type: GraphQLObjectType | GraphQLInterfaceType,\n  iface: GraphQLInterfaceType,\n): ReadonlyArray<NamedTypeNode> {\n  const { astNode, extensionASTNodes } = type;\n  const nodes: ReadonlyArray<\n    | ObjectTypeDefinitionNode\n    | ObjectTypeExtensionNode\n    | InterfaceTypeDefinitionNode\n    | InterfaceTypeExtensionNode\n  > = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;\n\n  return nodes\n    .flatMap((typeNode) => typeNode.interfaces ?? [])\n    .filter((ifaceNode) => ifaceNode.name.value === iface.name);\n}\n\nfunction getUnionMemberTypeNodes(\n  union: GraphQLUnionType,\n  typeName: string,\n): ReadonlyArray<NamedTypeNode> {\n  const { astNode, extensionASTNodes } = union;\n  const nodes: ReadonlyArray<UnionTypeDefinitionNode | UnionTypeExtensionNode> =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;\n\n  return nodes\n    .flatMap((unionNode) => /* c8 ignore next */ unionNode.types ?? [])\n    .filter((typeNode) => typeNode.name.value === typeName);\n}\n\nfunction getDeprecatedDirectiveNode(\n  definitionNode: Maybe<{\n    readonly directives?: ReadonlyArray<DirectiveNode> | undefined;\n  }>,\n): Maybe<DirectiveNode> {\n  return definitionNode?.directives?.find(\n    (node) => node.name.value === GraphQLDeprecatedDirective.name,\n  );\n}\n"]}